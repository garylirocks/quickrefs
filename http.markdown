# HTTP

- [Caching](#caching)
  - [Cache Validating](#cache-validating)
  - [`Cache-Control`](#cache-control)
  - [Invalidating and updating cached responses](#invalidating-and-updating-cached-responses)
  - [Caching checklist](#caching-checklist)
  - [Nginx server configs](#nginx-server-configs)

## Caching

[HTTP Caching - Google Developers](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching)

![Caching headers](images/http-request.png)

Caching headers:

- `Cache-Control`

  - specifies caching policy: who can cache (browser or intermediate caches), under which conditions and for how long;
  - defined in HTTP/1.1 and supersedes previous headers (e.g. `Expires`);

- `ETag`

  - used for cache validation;
  - generated by the server, is typically a hash or fingerprint of the reource;

### Cache Validating

![Cache validation](images/http-cache-control.png)

- Whe the same resource is requested again, the browser has it in its cache, but expired;
- Then the browser sends a request with the ETag value in `In-None-Match` header;
- The server checks whether the token has changed for the requested resource, if not, then it doesn't return the resouce, just return `304 Not Modified`, the browser can then reuse the cached resource and update the cache time;

### `Cache-Control`

Values for `Cache-Control`

- `no-store`

  - disallow the browser and all intermediate caches from storing the response, should always be downloaded in full from the server;
  - suitable for private personal or banking data;

- `no-cache`

  - response can be stored, but any subsequent request need to check the server if the resource has changed;

- `public` vs. `private`

  - `public` means the response can be cached, it's not necessary most of the time, it's implicit if you use `max-age`;
  - `private` indicates a browser can cache the response, but not intermediate caches, e.g. if a HTML page contains private user information, it can be cached by a broswer, but a CDN should not cache it;

- `max-age`

  - indicates for how many seconds the resource is allowed to be reused, e.g. `max-age=60`;

- `s-maxage`: used by CDNs and other intermediate caches, overrides `max-age` and `Expires`;

![Define cache policy](images/http-cache-decision-tree.png)

You can use the above diagram to define the optimal cache policy for your resources, here are some examples:

- `max-age=86400` can be cached by browser and any intermediate caches for up to 1 day;
- `private, max-age=600` can be cached by the browser for up to 10 minutes;
- `no-store` disallow any cache;

### Invalidating and updating cached responses

- Local caches are used until the resource 'expires';
- Embedding a file content fingerprint in the URL enables you to force the client to update to a new version of the response;

![Cache hierarchy](images/http-cache-hierarchy.png)

- The HTML is marked with `no-cache`, so the browser always revalidate it on every request. Since the markup contains static resource urls with fingerprint, so whenever one of those static resources updates, the HTML file changes, it will be downloaded again; A `304` status code is returned if nothing changed;
- The CSS is allowed to be cached by the browser and intermediate caches for 1 year, whenever it updates, the fingerprint will change, which triggers the HTML change, so it will be re-downloaded;
- The JS file is similar to the CSS file, however it is marked as `private`, can only be cached by the browser;

### Caching checklist

- **Use consistent URLs**, if the same content is served on different URLs, they are treated as different resources by the browser, and get feteched multiple times;
- **Ensure the server provides a validation token (ETag)**
- **Identify which resources can be cached by intermediate caches**, responses that are identical for all users are great candidates to be cached by a CDN;
- **Determine the optimal cache lifetime to each resource**: set a proper `max-age` for different resources;
- **Determine the best cache hierarchy**: setting a short or `no-cache` lifetime for a containing HTML document(or an entry JS file which loads other JS files) and a long lifetime for contained resources with fingerprinted URLs is usually a good strategy;
- **Splitting code**: split out the frequently updated part of your code to separate files, this allows the remainder of the content (e.g. library code that doesn't change very often) to be fetched from cache;

### Nginx server configs

- Nginx uses `etag on` by default, which generates the `ETag` response header (http://nginx.org/en/docs/http/ngx_http_core_module.html#etag);
- `expires` directive sets `Expires` and `Cache-Control` headers(`max-age` is calculated based on the time specified), see http://nginx.org/en/docs/http/ngx_http_headers_module.html

  ```nginx
  expires    off;                       # default value
  expires    24h;                       # expires in 24 hours from now
  expires    modified +24h;             # relative to modified time
  expires    @24h;                      # specify a time of day
  expires    0;
  expires    -1;
  expires    epoch;                     # 'Thu, 01 Jan 1970 00:00:01 GMT', no-cache
  add_header Cache-Control private;     # add Cache-Control diretly
  ```

  You can also set it based on MIME type of resources:

  ```nginx
  map $sent_http_content_type $expires {
    default                 off;
    text/html               epoch;
    text/css                max;
    application/javascript  max;
    application/pdf         30d;
    ~image/                 max;  # regexp matching all image MIME types
  }

  server {
    listen 80 default_server;
    listen [::]:80 default_server;

    expires $expires;
  ```
